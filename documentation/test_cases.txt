** echo **
echo

echo hallo daar

"echo" hallo daar

echo "hallo daar"

"echo' hallo daar                   --> Error multiple line command (wacht op error functie sophie)

echo hallo daar | echo hoi maran

echo hallo daar ; echo hoi maran

echo hallo >file1 >file2

echo hallo >file1 >file2 maran

echo hallo >file1 >file2 >>file3 maran siemons

echo hallo <file1 >file2




echo $USER""			-->msiemons
echo $USER"				-->not closed

echo $USER_


***************************
** 			cd 			**
***************************

1 niveau omhoog:
cd ..

HOME:
cd
cd ~/

Absoluut pad:
/Users/msiemons/Desktop/map_1

Relatief pad:
cd ../Documents/Git_maran


***************************
**		export			**
***************************

export
export ZZZ
export ZZZ=
export ZZZ=new_value
export ZZZ======new
export ZZZ=new YYY=new2 XXX===new3
export $USER
export TEST=$USER4857987345
export 123$USER---

***************************
**		export & env	**
***************************
1. export MARANSIEMONS
2. env						--> Niet in env zichtbaar

1. export MARANSIEMONS=lief
2. env						--> Wel in env zichtbaar


***************************
** 		Expansion		 **
***************************

echo $
echo $USER
echo $USER'				--> not complete
echo $USER_				--> underscore is alphanummeriek
echo 123$USER----
echo 123$USER----$

echo abc$USERdef
echo abc$USER123
echo abc$POEPdef

echo $USER "$USER" '$USER'
export TEST_$USER=hallo$LOGNAME

***************************
** 		Flauw 			**
***************************

1. export TEST=/Users/maran/Desktop/minishell
2. cd $IETSONBESTAANDS				---> moet naar home Git_maran
3  cd $IETSONBESTAANDS	.. 			--->ignores eerste en gaat naar niveau hoger
4. cd $POEP $MEERPOEP ..

Dus als er een $ voorstaat en hij bestaat niet, dan wordt deze gedelete.


***************************
** 		Remco			**
***************************

Iets met \ en ctrl D

***************************
** 		Exit_codes		**
***************************
- Invalid identifiers testen: getallen, tekens, $ etc.
- Testen met echo $?
- 


echojhdfjhjdkh				-->127		bash: echojhdfjhjdkh: command not found

echo	[Weet niet hoe te testen]
cd poep						--> 1
pwd -k						--> 1		+ bash: pwd: -k: invalid option



unset -k					--> 2		+ ash: unset: -k: invalid option
unset						--> 0		Ik had foutcode verwacht, maar is niet.
unset %						--> 1		bash: unset: `%': not a valid identifier
unset 3						--> 1


<<<<<<< HEAD


***************************
** 		breek de boel		**
***************************
 echo | poep

 echo | cd .. | pwd

 echo
=======
***************************
** 		Maak helemaal kapot	**
***************************

echo
echo hoi
cd poep
ls 
"ls"
test

***************************
** 		Exit + exit_codes**
***************************
- Let op error_message + exit_code

exit
exit a
exit a 1
exit 99
exit 3 a
exit 55 99
=======

***************************
** 		Executables		**
***************************
/bin/ls
/binn/ls			--> No such file or directory




***************************
** 		Single quotes	**
***************************
echo hallo 'ma\"ran' siemons				\" inside letterlijk
hallo ma\"ran siemons

echo hallo 'ma\'ran' siemons
Multiple line error

echo hallo 'ma\'ran'' siemons							
hallo ma\ran siemons						Hij ziet de \ niet als escape, print gewoon \

echo 'ma\'									Hij ziet de \ niet als escape, print gewoon \
ma\

echo 'hallo$USER'							
hallo$USER

echo 'hallo\$USER'
hallo\$USER

echo '\$?'
\$?

echo '$USER'
$USER


***************************
** 		Double quotes	**
***************************

echo "\poep"
\poep
echo \poep
poep

echo "poep\""
poep"
echo "poep\'"
poep\'

echo "poep\"
multiple line error

echo "hallo\"\poep"
hallo"\poep







echo \"						--> check

echo "123\'456"				--> nu alleen als binnen quotes en na de backslash ook een quote komt.

echo \$?					--> check

----

 echo '$USER'$USER

 echo '$USER'$USER\$USER/"$USER"




----
echo 123\poep		--> verwijdert \
123poep

echo "123\poep"		--> verwijdert helemaal niks??
123\poep

echo "123\$USER"	--> voor $ wel


 ---
echo "$USER"
maran

 echo "\$USER"		Verwijdert \ en werking $ is weg door \
$USER


 echo '\$USER'		letterlijk binnen de haakjes (Singel quotes belangrijker dan \)
\$USER

 echo "'\$USER'"	In dubbel quote werkt \ nog wel (verwijder + werking $ weg), ziet single quotes gewoon als tekst?
'$USER'				Dus eerst op compleetheid dubbel checken, dan \ en negeer '
					Singel quotes hoeven zelfs niet compleet te zijn.

echo '"\$USER"'		Andersom alles letterlijk
"\$USER"

----brain fart----
echo ' poep'123' '		Toch niet alles letterlijk. Single quotes binnen single quotes werken wel.
 poep123 				Deze moeten worden verwijderd. NEE KLOPT NIET>

echo ' poep'123 '		Moeten zelfs compleet zijn (geldt enkel voor single quotes)
> multiple line			Logisch want hij ziet 3e quote als alleen

-------------------